<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Opossum Search</title>
    <link rel="stylesheet" href="/static/css/style.css">
</head>
<body>
<!-- AI Background Overlay -->
<div id="ai-background-overlay" class="ai-background-overlay">
    <div id="ai-background-content" class="ai-background-content"></div>
</div>

<div id="search-container">
    <img id="logo" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/27/Opossum_2.jpg/292px-Opossum_2.jpg" alt="Opossum Logo">

    <div id="chat-display">
    </div>
    <label for="user-input"></label><textarea id="user-input" placeholder="Type your message..."></textarea>
    <button id="browse-button">Browse...</button>
    <button id="send-button">Send</button>
    <button id="svg-button" title="Generate visualization">Visualize</button>

    <div class="svg-menu" style="display: none;">
        <div class="svg-option" data-type="service_status">Service Status</div>
        <div class="svg-option" data-type="failover_process">Failover Process</div>
        <div class="svg-option" data-type="capability_degradation">Capability Levels</div>
    </div>
    
    <!-- Status Dashboard -->
    <div id="status-dashboard" class="status-dashboard" style="display: none;">
        <div class="dashboard-header">
            <div class="dashboard-title">Service Status Dashboard</div>
            <div class="dashboard-controls">
                <button id="refresh-status" class="refresh-button">Refresh</button>
                <div class="auto-refresh">
                    <input type="checkbox" id="auto-refresh" checked>
                    <label for="auto-refresh">Auto-refresh (30s)</label>
                </div>
            </div>
        </div>
        <div id="status-timestamp" class="status-timestamp">Last updated: Never</div>
        <div id="service-grid" class="service-grid">
            <!-- Service cards will be added here dynamically -->
        </div>
    </div>
</div>
<footer>Powered by opossum search</footer>

<script>
    const chatDisplay = document.getElementById('chat-display');
    const userInput = document.getElementById('user-input');
    const sendButton = document.getElementById('send-button');
    const browseButton = document.getElementById('browse-button');
    const svgButton = document.getElementById('svg-button');
    const svgMenu = document.querySelector('.svg-menu');
    const svgOptions = document.querySelectorAll('.svg-option');
    
    let conversationStage = "greeting";
    let svgModeActive = false;
    const availableTopics = { // Simulate browse topics
        "diet": "Opossum Diet",
        "habitat": "Opossum Habitat",
        "behavior": "Opossum Behavior",
        "florida_opossums": "Opossums in Florida",
        "snake_resistance": "Opossum Snake Resistance"
    };

    function addMessage(message, sender, isTyping = false) {
        const messageDiv = document.createElement('div');
        messageDiv.textContent = message;
        messageDiv.classList.add(sender + '-message'); // Add sender class for styling
        if (isTyping) {
            messageDiv.classList.add('bot-typing'); // Add typing class
        }
        chatDisplay.appendChild(messageDiv);
        chatDisplay.scrollTop = chatDisplay.scrollHeight; // Scroll to bottom
    }

    function addSVGMessage(svgContent, base64Image) {
        const svgContainer = document.createElement('div');
        svgContainer.classList.add('svg-container');
        
        // Create image element
        const img = document.createElement('img');
        img.src = `data:image/png;base64,${base64Image}`;
        img.classList.add('svg-image');
        img.alt = 'Generated visualization';
        
        svgContainer.appendChild(img);
        chatDisplay.appendChild(svgContainer);
        chatDisplay.scrollTop = chatDisplay.scrollHeight; // Scroll to bottom
    }

    // Initialize with fallback simulation functions in case API isn't available
    let usingAPI = true;

    // GraphQL helper functions
    async function graphqlRequest(query, variables = {}) {
        try {
            const response = await fetch('/graphql', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    query,
                    variables
                })
            });
            const data = await response.json();
            if (data.errors) {
                throw new Error(data.errors[0].message);
            }
            return data.data;
        } catch (error) {
            console.error('GraphQL Error:', error);
            throw error;
        }
    }

    // Service status queries and mutations
    async function fetchServiceStatus() {
        const query = `
            query GetServiceStatus {
                service_status {
                    service_data
                    svg_content
                    last_updated
                }
            }
        `;
        
        try {
            addMessage("Fetching real-time service status...", "bot", true);
            const data = await graphqlRequest(query);
            
            // Remove typing indicator
            const typingIndicator = chatDisplay.querySelector('.bot-typing');
            if (typingIndicator) {
                chatDisplay.removeChild(typingIndicator);
            }
            
            if (data.service_status) {
                const serviceData = JSON.parse(data.service_status.service_data);
                updateServiceDashboard(serviceData, data.service_status.last_updated);
                
                // Add SVG visualization if available
                if (data.service_status.svg_content) {
                    document.getElementById('service-visualization').innerHTML = data.service_status.svg_content;
                }
            }
        } catch (error) {
            console.error('Error fetching service status:', error);
            addMessage("Sorry, there was an error fetching the service status.", "bot");
        }
    }

    async function forceServiceCheck() {
        const mutation = `
            mutation ForceServiceCheck {
                force_service_check
            }
        `;
        
        try {
            const data = await graphqlRequest(mutation);
            if (data.force_service_check) {
                fetchServiceStatus();
            }
        } catch (error) {
            console.error('Error forcing service check:', error);
        }
    }

    // Chat mutations
    async function sendMessageToAPI(userMessage, generateSvg = false) {
        try {
            const imageElement = document.getElementById('preview-image');
            const hasImage = imageElement.style.display !== 'none';
            let imageData = null;

            if (hasImage) {
                imageData = imageElement.src;
                document.getElementById('clear-image').click();
            }
            
            const mutation = `
                mutation SendChatMessage($input: ChatInput!) {
                    chat(input: $input) {
                        response
                        next_stage
                        has_svg
                        svg_content
                        base64_image
                        error
                    }
                }
            `;
            
            const variables = {
                input: {
                    message: userMessage,
                    session_id: sessionStorage.getItem('session_id') || Date.now().toString(),
                    has_image: hasImage,
                    image_data: imageData
                }
            };
            
            const data = await graphqlRequest(mutation, variables);
            const chatResponse = data.chat;
            
            if (chatResponse.error) {
                throw new Error(chatResponse.error);
            }
            
            // Update conversation stage
            if (chatResponse.next_stage) {
                conversationStage = chatResponse.next_stage;
            }
            
            // Display SVG if present
            if (chatResponse.has_svg && chatResponse.svg_content && chatResponse.base64_image) {
                addSVGMessage(chatResponse.svg_content, chatResponse.base64_image);
            }
            
            return chatResponse.response;
            
        } catch (error) {
            console.error('Error:', error);
            usingAPI = false;
            return getBotResponse(userMessage);
        }
    }

    // Image processing mutations
    async function processImage(imageData, effects = {}) {
        const mutation = `
            mutation ProcessImage($imageData: String!, $effects: ImageEffects) {
                process_image(image_data: $imageData, effects: $effects) {
                    processed_image
                    thumbnail
                    info {
                        width
                        height
                        format
                        size
                    }
                }
            }
        `;
        
        const variables = {
            imageData,
            effects
        };
        
        try {
            const data = await graphqlRequest(mutation, variables);
            return data.process_image;
        } catch (error) {
            console.error('Error processing image:', error);
            throw error;
        }
    }

    // Submit feedback mutation
    async function submitFeedback(message, rating) {
        const mutation = `
            mutation SubmitFeedback($message: String!, $rating: Int!) {
                submit_feedback(message: $message, rating: $rating)
            }
        `;
        
        const variables = {
            message,
            rating
        };
        
        try {
            await graphqlRequest(mutation, variables);
        } catch (error) {
            console.error('Error submitting feedback:', error);
        }
    }

    // End conversation mutation
    async function endConversation(sessionId) {
        const mutation = `
            mutation EndConversation($sessionId: String!) {
                end_conversation(session_id: $sessionId)
            }
        `;
        
        const variables = {
            sessionId
        };
        
        try {
            await graphqlRequest(mutation, variables);
        } catch (error) {
            console.error('Error ending conversation:', error);
        }
    }

    // Background text generation query
    async function generateBackgroundText() {
        const query = `
            query GenerateGibberish($numLines: Int) {
                generate_gibberish(num_lines: $numLines) {
                    text
                    emojis
                }
            }
        `;
        
        const variables = {
            numLines: 25
        };
        
        try {
            const data = await graphqlRequest(query, variables);
            return data.generate_gibberish;
        } catch (error) {
            console.error('Error generating background text:', error);
            return { text: '', emojis: [] };
        }
    }

    function getBotResponse(userMessage) { // Fallback simulation function
        userMessage = userMessage.toLowerCase().trim();
        let botMessage = "";

        switch (conversationStage) {
            case "greeting":
                if (userMessage.includes("hi") || userMessage.includes("hello")) {
                    botMessage = "Greetings! I am your Opossum Information Assistant. How can I help you explore the fascinating world of opossums today?";
                    conversationStage = "initial_query";
                } else {
                    botMessage = "Sorry, I didn't catch that. Perhaps start with a friendly 'Hello' or ask me about opossums?";
                }
                break;

            case "initial_query":
                // ... rest of the simulation logic
                botMessage = "I'm in simulation mode now because the API isn't available. Let's talk about opossums!";
                break;

            default:
                botMessage = "I'm in simulation mode. Please ask something about opossums.";
        }
        return botMessage;
    }

    async function handleMessage(generateSvg = false) {
        const message = userInput.value;
        if (message.trim() !== "") {
            addMessage(message, "user");
            userInput.value = ""; // Clear input

            // Show typing indicator
            addMessage("Bot is typing...", "bot", true);

            // Get response from API
            let botMessage;
            if (usingAPI) {
                botMessage = await sendMessageToAPI(message, generateSvg);
            } else {
                botMessage = getBotResponse(message);
            }

            // Remove typing indicator
            const typingIndicator = chatDisplay.querySelector('.bot-typing');
            if (typingIndicator) {
                chatDisplay.removeChild(typingIndicator);
            }

            // Display response
            addMessage(botMessage, "bot");
        }
    }

    async function generateSVGVisualization(svgType) {
        // Show typing indicator
        addMessage("Generating visualization...", "bot", true);
        
        try {
            const response = await fetch('/generate-svg', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    type: svgType,
                    data: {} // This could be populated with real data if needed
                })
            });

            const data = await response.json();
            
            // Remove typing indicator
            const typingIndicator = chatDisplay.querySelector('.bot-typing');
            if (typingIndicator) {
                chatDisplay.removeChild(typingIndicator);
            }
            
            if (data.svg_content && data.base64_image) {
                addSVGMessage(data.svg_content, data.base64_image);
                
                // Add explanation message based on type
                let explanation = "";
                if (svgType === 'service_status') {
                    explanation = "Here's the current service availability status visualization showing Gemini API, Ollama, and Transformers services.";
                } else if (svgType === 'failover_process') {
                    explanation = "This diagram illustrates the failover process when services become unavailable, showing how requests flow from Gemini to Ollama to Transformers as fallback options.";
                } else if (svgType === 'capability_degradation') {
                    explanation = "This visualization shows the capability degradation across different services, from full capabilities with Gemini API to minimal capabilities with client-side processing.";
                }
                
                addMessage(explanation, "bot");
            } else {
                addMessage("Sorry, I couldn't generate the visualization.", "bot");
            }
        } catch (error) {
            console.error('Error generating SVG:', error);
            
            // Remove typing indicator
            const typingIndicator = chatDisplay.querySelector('.bot-typing');
            if (typingIndicator) {
                chatDisplay.removeChild(typingIndicator);
            }
            
            addMessage("Sorry, there was an error generating the visualization.", "bot");
        }
    }

    function handleBrowse() {
        // Simulate browsing more realistically, with topics
        let browseMessage = "Okay, exploring topics... Here are some opossum topics you can ask me about:\n\n";
        let topicList = Object.values(availableTopics).map(topic => "* " + topic).join("\n"); // Create bulleted list
        browseMessage += topicList + "\n\nJust type the name of a topic to learn more!";

        // Show typing indicator
        addMessage("Bot is typing...", "bot", true);

        // Simulate delay, then show response
        setTimeout(() => {
            // Remove typing indicator
            const typingIndicator = chatDisplay.querySelector('.bot-typing');
            if (typingIndicator) {
                chatDisplay.removeChild(typingIndicator);
            }
            addMessage(browseMessage, "bot");
        }, 1000);
    }

    function toggleSVGMenu() {
        if (svgMenu.style.display === 'none' || svgMenu.style.display === '') {
            svgMenu.style.display = 'flex';
            svgModeActive = true;
            svgButton.style.backgroundColor = '#9e9e9e';
        } else {
            svgMenu.style.display = 'none';
            svgModeActive = false;
            svgButton.style.backgroundColor = '#34a853';
        }
    }

    sendButton.addEventListener('click', () => handleMessage(svgModeActive));
    
    userInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleMessage(svgModeActive);
        }
    });
    
    browseButton.addEventListener('click', function() {
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        fileInput.onchange = function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const imageData = event.target.result;
                    document.getElementById('preview-image').src = imageData;
                    document.getElementById('preview-image').style.display = 'block';
                    document.getElementById('clear-image').style.display = 'inline-block';
                    document.getElementById('image-upload-container').style.display = 'block';
                };
                reader.readAsDataURL(file);
            }
        };
        fileInput.click();
    });
    
    svgButton.addEventListener('click', toggleSVGMenu);
    
    // Add event listeners for SVG options
    svgOptions.forEach(option => {
        option.addEventListener('click', function() {
            const svgType = this.getAttribute('data-type');
            
            if (svgType === 'service_status') {
                // For service status, use the real-time data from the API
                fetchServiceStatus();
                // Show the dashboard
                document.getElementById('status-dashboard').style.display = 'block';
            } else {
                // For other visualization types, use the existing function
                generateSVGVisualization(svgType);
            }
            
            svgMenu.style.display = 'none';
            svgModeActive = false;
            svgButton.style.backgroundColor = '#34a853';
        });
    });
    
    // Service Status Dashboard functionality
    let autoRefreshInterval = null;
    
    // Function to fetch service status using GraphQL
    async function fetchServiceStatus() {
        try {
            addMessage("Fetching real-time service status...", "bot", true);
            
            const response = await fetch('/graphql', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    query: `
                        query GetServiceStatus {
                            service_status {
                                name
                                available
                                status
                                response_time
                                availability
                                last_checked
                            }
                        }
                    `
                }),
            });
            
            const data = await response.json();
            
            // Remove typing indicator
            const typingIndicator = chatDisplay.querySelector('.bot-typing');
            if (typingIndicator) {
                chatDisplay.removeChild(typingIndicator);
            }
            
            if (data.data && data.data.service_status) {
                const serviceData = {};
                data.data.service_status.forEach(service => {
                    serviceData[service.name] = {
                        available: service.available,
                        status: service.status,
                        response_time: service.response_time,
                        availability: service.availability,
                        last_checked: service.last_checked
                    };
                });
                
                // Update the dashboard with the service data
                updateServiceDashboard(serviceData);
                
                // Add explanation message
                const onlineServices = data.data.service_status.filter(s => s.status === 'online').length;
                const explanation = `Real-time service status: ${onlineServices}/3 services online. Response times and availability statistics are displayed in the visualization.`;
                addMessage(explanation, "bot");
            }
        } catch (error) {
            console.error('Error fetching service status:', error);
            addMessage("Sorry, there was an error fetching the service status.", "bot");
        }
    }
    
    // Process service status data and display SVG
    function processServiceStatusData(data) {
        // Create renderer-like functionality
        const base64Image = data.base64_image || '';
        
        // Add the image to the chat
        addSVGMessage(data.svg_content, base64Image);
    }
    
    // Update the service dashboard with real-time data
    function updateServiceDashboard(serviceData, lastUpdated) {
        const dashboardElement = document.getElementById('status-dashboard');
        const serviceGridElement = document.getElementById('service-grid');
        const timestampElement = document.getElementById('status-timestamp');
        
        // Clear existing service cards
        serviceGridElement.innerHTML = '';
        
        // Update timestamp
        if (lastUpdated) {
            const formattedDate = new Date(lastUpdated).toLocaleString();
            timestampElement.textContent = `Last updated: ${formattedDate}`;
        }
        
        // Define service order and display names
        const serviceOrder = ['gemini', 'ollama', 'transformers', 'redis'];
        const serviceDisplayNames = {
            'gemini': 'Gemini API',
            'ollama': 'Ollama',
            'transformers': 'Transformers',
            'redis': 'Redis Cache'
        };
        
        // Create a card for each service in order
        for (const serviceName of serviceOrder) {
            const metrics = serviceData[serviceName];
            if (!metrics) continue;
            
            const status = metrics.status || 'offline';
            const responseTime = metrics.response_time || 'N/A';
            const availability = metrics.availability || 0;
            
            const serviceCard = document.createElement('div');
            serviceCard.className = 'service-card';
            serviceCard.innerHTML = `
                <div class="service-name">${serviceDisplayNames[serviceName] || serviceName}</div>
                <div class="service-status status-${status}">${status.toUpperCase()}</div>
                <div class="service-metrics">
                    <div>Response: ${responseTime}ms</div>
                    <div>Availability: ${availability}%</div>
                </div>
            `;
            
            serviceGridElement.appendChild(serviceCard);
        }
        
        // Show the dashboard
        dashboardElement.style.display = 'block';
        
        // Update the explanation message
        const onlineServices = Object.values(serviceData).filter(s => s.status === 'online').length;
        const explanation = `Real-time service status: ${onlineServices}/4 services online. Response times and availability statistics are displayed in the visualization.`;
        addMessage(explanation, "bot");
    }
    
    // Setup auto-refresh functionality
    document.getElementById('refresh-status').addEventListener('click', fetchServiceStatus);
    
    document.getElementById('auto-refresh').addEventListener('change', function() {
        if (this.checked) {
            // Start auto-refresh if checked
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
            autoRefreshInterval = setInterval(fetchServiceStatus, 30000); // 30 seconds
        } else {
            // Stop auto-refresh if unchecked
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }
    });
    
    // Force a service check
    async function forceSserviceCheck() {
        try {
            const response = await fetch('/graphql', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    query: `
                        mutation ForceServiceCheck {
                            force_service_check
                        }
                    `
                })
            });
            
            const data = await response.json();
            
            if (data.data && data.data.force_service_check) {
                // Fetch the updated service status if check was successful
                fetchServiceStatus();
            }
        } catch (error) {
            console.error('Error forcing service check:', error);
        }
    }
    
    // Initialize auto-refresh
    const autoRefreshCheckbox = document.getElementById('auto-refresh');
    if (autoRefreshCheckbox.checked) {
        autoRefreshInterval = setInterval(fetchServiceStatus, 30000); // 30 seconds
    }
    
    // Add clear image button functionality
    document.getElementById('clear-image').addEventListener('click', function() {
        document.getElementById('preview-image').src = '';
        document.getElementById('preview-image').style.display = 'none';
        document.getElementById('clear-image').style.display = 'none';
        document.getElementById('image-upload-container').style.display = 'none';
    });

    document.getElementById('user-input').insertAdjacentHTML('afterend', `
    <div id="image-upload-container" style="margin-top: 10px; display: none;">
        <img id="preview-image" style="max-width: 200px; max-height: 200px; display: none;"  alt="Generated image" src=""/>
        <button id="clear-image" style="display: none;">Clear Image</button>
    </div>
`   );
    // Initial bot message
    addMessage("Hello! I'm the Opossum Search Helper Bot. How can I assist you today?", "bot");

    // AI Background Gibberish Functionality
    let gibberishRefreshInterval = null;
    
    // Function to fetch gibberish AI text for the background
    async function fetchGibberishText() {
        try {
            const lines = Math.floor(window.innerHeight / 15); // Rough estimate of lines needed
            const response = await fetch(`/generate-gibberish?lines=${lines}`);
            const data = await response.json();
            
            if (data.gibberish && Array.isArray(data.gibberish)) {
                return data.gibberish;
            } else {
                return [];
            }
        } catch (error) {
            console.error('Error fetching gibberish text:', error);
            return [];
        }
    }
    
    // Function to update the background with new opossum-themed text
    async function updateGibberishBackground() {
        const backgroundContent = document.getElementById('ai-background-content');
        const lines = await fetchGibberishText();
        
        if (lines.length === 0) {
            return;
        }
        
        // Process lines to animate individual tokens and highlight opossum terms
        const processedLines = lines.map(line => {
            // First find and mark emojis for special animation
            const emojiRegex = /(\p{Emoji}+)/gu;
            let processedLine = line.replace(emojiRegex, (match, emoji) => {
                const delay = Math.floor(Math.random() * 10);
                return `<span class="emoji-token" style="--emoji-delay:${delay}">${emoji}</span>`;
            });
            
            // Special highlight for scientific names and important opossum terms
            const opossumTerms = [
                "Didelphis", "opossum", "marsupial", "joeys", "pouch", "thanatosis", 
                "playing dead", "prehensile", "Virginia opossum"
            ];
            
            // Highlight important opossum terms
            opossumTerms.forEach(term => {
                // Use word boundary to match whole words only
                const regex = new RegExp(`\\b(${term})\\b`, 'gi');
                processedLine = processedLine.replace(regex, '<span class="ai-background-highlight-special">$1</span>');
            });
            
            // Now animate some random individual words/tokens (but not those already highlighted)
            // Split into tokens, preserving HTML tags
            const tokens = [];
            let currentToken = '';
            let inTag = false;
            
            for (let i = 0; i < processedLine.length; i++) {
                const char = processedLine[i];
                if (char === '<') {
                    if (currentToken) tokens.push({text: currentToken, isTag: false});
                    currentToken = char;
                    inTag = true;
                } else if (char === '>') {
                    currentToken += char;
                    tokens.push({text: currentToken, isTag: true});
                    currentToken = '';
                    inTag = false;
                } else if (!inTag && (char === ' ' || char === '\n')) {
                    if (currentToken) tokens.push({text: currentToken, isTag: false});
                    tokens.push({text: char, isTag: false, isWhitespace: true});
                    currentToken = '';
                } else {
                    currentToken += char;
                }
            }
            
            if (currentToken) tokens.push({text: currentToken, isTag: false});
            
            // Randomly animate some non-tag, non-highlighted tokens
            const animatedTokens = tokens.map(token => {
                if (token.isTag || token.isWhitespace) {
                    return token.text;
                }
                
                // Don't animate tokens that are already part of a highlight or emoji
                if (tokens.some(t => t.isTag && 
                    (t.text.includes('highlight') || t.text.includes('emoji')) && 
                    tokens.indexOf(t) < tokens.indexOf(token) &&
                    tokens.some(et => et.isTag && et.text.includes('/span') && 
                        tokens.indexOf(et) > tokens.indexOf(token)))) {
                    return token.text;
                }
                
                // Randomly animate about 20% of remaining tokens
                if (Math.random() < 0.2) {
                    const delay = Math.floor(Math.random() * 10);
                    return `<span class="token-animate" style="--token-delay:${delay}">${token.text}</span>`;
                }
                
                return token.text;
            });
            
            return animatedTokens.join('');
        });
        
        // Create a snake-like layout by varying indentation randomly
        const formattedLines = processedLines.map(line => {
            // Add random indentation for snake-like effect
            const indent = ' '.repeat(Math.floor(Math.random() * 30));
            return indent + line;
        });
        
        // Set the content
        backgroundContent.innerHTML = formattedLines.join('\n');
    }
    
    // Initialize the gibberish background
    function initGibberishBackground() {
        // Initial update
        updateGibberishBackground();
        
        // Set interval to refresh content periodically (every 30 seconds)
        gibberishRefreshInterval = setInterval(updateGibberishBackground, 30000);
    }
    
    // Start the background when the page loads
    window.addEventListener('load', initGibberishBackground);
    
    // Clean up on page unload
    window.addEventListener('unload', function() {
        if (gibberishRefreshInterval) {
            clearInterval(gibberishRefreshInterval);
        }
    });
</script>
</body>
</html>